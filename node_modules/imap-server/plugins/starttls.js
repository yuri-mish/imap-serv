
var tls = require('tls');
var crypto = require('crypto');
var emit = require('events').EventEmitter.prototype.emit;

var plugin = module.exports;

plugin.initialize = function(opts) {
    if(!opts || !opts.key || !opts.cert) {
        throw new Error("Can't enable STARTTLS plugin: missing certs configuration");
    }
    else {
        //opts.ciphers = 'ALL';
        _credentials = tls.createSecureContext({
	    key: opts.key,
	    cert: opts.cert
	});
	this.notes._credentials = _credentials;
 //crypto.createCredentials(opts);
    }
};

plugin.getCapabilities = function(connection) {
    if(this.notes._credentials && !connection.isSecure) {
        return ['STARTTLS'];
    }
    else {
        return [];
    }
};

var events = ['error', 'close'];

plugin.starttls = function(connection, tag) {
    if(!this.notes._credentials) {
        throw new Error('No credentials available');
    }
    connection.pause();

    var socket = connection.stream;
    socket.ondata = null;
    socket.unpipe();
//    var securePair = tls.createSecurePair(this.notes._credentials, true, false, false);
//    var clearText = securePair.cleartext;
    var secure_socket = new tls.TLSSocket(socket,{
	secureContext: this.notes._credentials,
	isServer: true,
    } );

    var clearText = secure_socket;

    for(var i=0; i<events.length; i++) {
        var event = events[i];
        var listeners = (socket.listeners(event) || []).slice(0);
        socket.removeAllListeners(event);
        for(var j=0; j<listeners.length; j++) {
            clearText.on(event, listeners[j]);
            socket.on(event, emit.bind(clearText, event));
        }
    }

//    securePair.fd = socket.fd;
//    clearText.socket = socket;
//    clearText.encrypted = securePair.encrypted;
    clearText.authorized = false;

    secure_socket.on('error', emit.bind(clearText, 'error'));
    secure_socket.on('secure', function() {
        var verifyError = (secure_socket.ssl || secure_socket._ssl).verifyError();

        // A cleartext stream has the boolean property 'authorized' to determine if it was verified by the CA. If 'authorized' is false, a property 'authorizationError' is set on the stream.
        if (verifyError) {
            secure_socket.authorized = false;
            secure_socket.authorizationError = verifyError;
        } else {
            secure_socket.authorized = true;
        }
        connection.stream = secure_socket;
        connection.isSecure = true;
        connection.resume();

        connection.callPlugins('secure', [connection]);
    });

    clearText._controlReleased = true;
    //socket.pipe(secure_socket.encrypted);
    socket.write(tag+' OK Begin TLS negotiation now\r\n');
    //secure_socket.encrypted.pipe(socket);
};

